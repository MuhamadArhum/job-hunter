"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChargingManager = exports.DEFAULT_DATASET_ITEM_EVENT = void 0;
exports.mergeChargeResults = mergeChargeResults;
exports.pushDataAndCharge = pushDataAndCharge;
const tslib_1 = require("tslib");
const core_1 = require("@crawlee/core");
const log_1 = tslib_1.__importDefault(require("@apify/log"));
exports.DEFAULT_DATASET_ITEM_EVENT = 'apify-default-dataset-item';
function mergeChargeResults(a, b) {
    return {
        eventChargeLimitReached: a.eventChargeLimitReached || b.eventChargeLimitReached,
        chargedCount: a.chargedCount + b.chargedCount,
        chargeableWithinLimit: Object.fromEntries(Object.entries(a.chargeableWithinLimit).map(([key, oldValue]) => [
            key,
            Math.min(oldValue, b.chargeableWithinLimit[key]),
        ])),
    };
}
/**
 * Handles pay-per-event charging.
 */
class ChargingManager {
    constructor(configuration, apifyClient) {
        Object.defineProperty(this, "configuration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: configuration
        });
        Object.defineProperty(this, "LOCAL_CHARGING_LOG_DATASET_NAME", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'charging_log'
        });
        Object.defineProperty(this, "PLATFORM_CHARGING_LOG_DATASET_ID_KEY", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 'CHARGING_LOG_DATASET_ID'
        });
        Object.defineProperty(this, "maxTotalChargeUsd", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "isAtHome", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "actorRunId", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "pricingModel", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "purgeChargingLogDataset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "useChargingLogDataset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "notPpeWarningPrinted", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "pricingInfo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "chargingState", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "chargingLogDataset", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "apifyClient", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.maxTotalChargeUsd =
            configuration.get('maxTotalChargeUsd') || Infinity; // convert `0` to `Infinity` in case the value is an empty string
        this.isAtHome = configuration.get('isAtHome');
        this.actorRunId = configuration.get('actorRunId');
        this.purgeChargingLogDataset = configuration.get('purgeOnStart');
        this.useChargingLogDataset = configuration.get('useChargingLogDataset');
        this.apifyClient = apifyClient;
    }
    get isPayPerEvent() {
        return this.pricingModel === 'PAY_PER_EVENT';
    }
    async fetchPricingInfo() {
        if (this.configuration.get('actorPricingInfo') &&
            this.configuration.get('chargedEventCounts')) {
            return {
                pricingInfo: JSON.parse(this.configuration.get('actorPricingInfo')),
                chargedEventCounts: JSON.parse(this.configuration.get('chargedEventCounts')),
                maxTotalChargeUsd: this.configuration.get('maxTotalChargeUsd') || Infinity,
            };
        }
        if (this.isAtHome) {
            if (this.actorRunId === undefined) {
                throw new Error('Actor run ID not found even though the Actor is running on Apify');
            }
            const run = await this.apifyClient.run(this.actorRunId).get();
            if (run === undefined) {
                throw new Error('Actor run not found');
            }
            return {
                pricingInfo: run.pricingInfo,
                chargedEventCounts: run.chargedEventCounts,
                maxTotalChargeUsd: run.options.maxTotalChargeUsd || Infinity,
            };
        }
        return {
            pricingInfo: undefined,
            chargedEventCounts: {},
            maxTotalChargeUsd: this.configuration.get('maxTotalChargeUsd') || Infinity,
        };
    }
    /**
     * Initialize the ChargingManager by loading pricing information and charging state via Apify API.
     */
    async init() {
        // Validate config - it may have changed since the instantiation
        if (this.useChargingLogDataset && this.isAtHome) {
            throw new Error('Using the ACTOR_USE_CHARGING_LOG_DATASET environment variable is only supported in a local development environment');
        }
        if (this.configuration.get('testPayPerEvent')) {
            if (this.isAtHome) {
                throw new Error('Using the ACTOR_TEST_PAY_PER_EVENT environment variable is only supported in a local development environment');
            }
        }
        // Retrieve pricing information
        const { pricingInfo, chargedEventCounts, maxTotalChargeUsd } = await this.fetchPricingInfo();
        if (this.configuration.get('testPayPerEvent')) {
            this.pricingModel = 'PAY_PER_EVENT';
        }
        else {
            this.pricingModel ?? (this.pricingModel = pricingInfo?.pricingModel);
        }
        // Load per-event pricing information
        if (pricingInfo?.pricingModel === 'PAY_PER_EVENT') {
            for (const [eventName, eventPricing] of Object.entries(pricingInfo.pricingPerEvent.actorChargeEvents)) {
                this.pricingInfo[eventName] = {
                    price: eventPricing.eventPriceUsd,
                    title: eventPricing.eventTitle,
                };
            }
            this.maxTotalChargeUsd = maxTotalChargeUsd;
        }
        this.chargingState = {};
        for (const [eventName, chargeCount] of Object.entries(chargedEventCounts ?? {})) {
            this.chargingState[eventName] = {
                chargeCount,
                totalChargedAmount: chargeCount * (this.pricingInfo[eventName]?.price ?? 0),
            };
        }
        if (!this.isPayPerEvent || !this.useChargingLogDataset) {
            return;
        }
        // Set up charging log dataset
        if (this.isAtHome) {
            const datasetId = await this.ensureChargingLogDatasetOnPlatform();
            this.chargingLogDataset = await core_1.Dataset.open(datasetId);
        }
        else {
            if (this.purgeChargingLogDataset) {
                const dataset = await core_1.Dataset.open(this.LOCAL_CHARGING_LOG_DATASET_NAME);
                await dataset.drop();
            }
            this.chargingLogDataset = await core_1.Dataset.open(this.LOCAL_CHARGING_LOG_DATASET_NAME);
        }
    }
    async ensureChargingLogDatasetOnPlatform() {
        const defaultStore = await core_1.KeyValueStore.open();
        const storedDatasetId = await defaultStore.getValue(this.PLATFORM_CHARGING_LOG_DATASET_ID_KEY);
        if (storedDatasetId !== null) {
            return storedDatasetId;
        }
        const dataset = await this.apifyClient.datasets().getOrCreate();
        await defaultStore.setValue(this.PLATFORM_CHARGING_LOG_DATASET_ID_KEY, dataset.id);
        return dataset.id;
    }
    /**
     * Get information about the pricing for this Actor.
     */
    getPricingInfo() {
        if (this.chargingState === undefined) {
            throw new Error('ChargingManager is not initialized');
        }
        return {
            pricingModel: this.pricingModel,
            isPayPerEvent: this.isPayPerEvent,
            maxTotalChargeUsd: this.maxTotalChargeUsd,
            perEventPrices: Object.fromEntries(Object.entries(this.pricingInfo).map(([eventName, { price }]) => [eventName, price])),
        };
    }
    /**
     * Charge for a specified number of events - sub-operations of the Actor.
     *
     * This method attempts to charge for the specified number of events, but may charge fewer
     * if doing so would exceed the total budget limit (`maxTotalChargeUsd`).
     *
     * @param options The name of the event to charge for and the number of events to be charged.
     */
    async charge({ eventName, count = 1, }) {
        var _a;
        const calculateChargeableWithinLimit = () => Object.fromEntries(Object.keys(this.pricingInfo).map((name) => [
            name,
            this.calculateMaxEventChargeCountWithinLimit(name),
        ]));
        if (!this.isPayPerEvent) {
            if (!this.notPpeWarningPrinted) {
                log_1.default.warning('Ignored attempt to charge for an event - the Actor does not use the pay-per-event pricing');
                this.notPpeWarningPrinted = true;
            }
            return {
                eventChargeLimitReached: false,
                chargedCount: 0,
                chargeableWithinLimit: calculateChargeableWithinLimit(),
            };
        }
        if (this.chargingState === undefined) {
            throw new Error('ChargingManager is not initialized');
        }
        /* START OF CRITICAL SECTION - no awaits here */
        const chargedCount = Math.min(count, this.calculateMaxEventChargeCountWithinLimit(eventName));
        if (chargedCount === 0) {
            return {
                eventChargeLimitReached: count > 0, // Only true if user wanted to charge but couldn't
                chargedCount: 0,
                chargeableWithinLimit: calculateChargeableWithinLimit(),
            };
        }
        const pricingInfo = this.pricingInfo[eventName] ?? {
            price: this.isAtHome ? 0 : 1, // Use a nonzero price for local development so that the maximum budget can be reached
            title: `Unknown event '${eventName}'`,
        };
        (_a = this.chargingState)[eventName] ?? (_a[eventName] = {
            chargeCount: 0,
            totalChargedAmount: 0,
        });
        this.chargingState[eventName].chargeCount += chargedCount;
        this.chargingState[eventName].totalChargedAmount +=
            chargedCount * pricingInfo.price;
        /* END OF CRITICAL SECTION */
        if (this.isAtHome) {
            if (eventName.startsWith('apify-')) {
                // Synthetic events (e.g. apify-default-dataset-item) are tracked locally only,
                // the platform handles them automatically based on dataset writes.
            }
            else if (this.pricingInfo[eventName] !== undefined) {
                await this.apifyClient
                    .run(this.actorRunId)
                    .charge({ eventName, count: chargedCount });
            }
            else {
                log_1.default.warning(`Attempting to charge for an unknown event '${eventName}'`);
            }
        }
        const timestamp = new Date().toISOString();
        if (this.chargingLogDataset !== undefined) {
            await this.chargingLogDataset.pushData({
                eventName,
                eventTitle: pricingInfo.title,
                eventPriceUsd: pricingInfo.price,
                chargedCount,
                timestamp,
            });
        }
        if (chargedCount < count) {
            const subject = count === 1 ? 'instance' : 'instances';
            log_1.default.info(`Charging ${count} ${subject} of '${eventName}' event would exceed maxTotalChargeUsd - only ${chargedCount} events were charged`);
        }
        return {
            eventChargeLimitReached: this.calculateMaxEventChargeCountWithinLimit(eventName) <= 0,
            chargedCount,
            chargeableWithinLimit: calculateChargeableWithinLimit(),
        };
    }
    /**
     * Get the number of events with given name that the Actor has charged for so far.
     */
    getChargedEventCount(eventName) {
        if (this.chargingState === undefined) {
            throw new Error('ChargingManager is not initialized');
        }
        return this.chargingState[eventName]?.chargeCount ?? 0;
    }
    /**
     * Get the maximum amount of money that the Actor is allowed to charge.
     */
    getMaxTotalChargeUsd() {
        if (this.chargingState === undefined) {
            throw new Error('ChargingManager is not initialized');
        }
        return this.maxTotalChargeUsd;
    }
    calculateTotalChargedAmount() {
        if (this.chargingState === undefined) {
            throw new Error('ChargingManager is not initialized');
        }
        const result = Object.values(this.chargingState)
            .map(({ totalChargedAmount }) => totalChargedAmount)
            .reduce((sum, inc) => sum + inc, 0);
        // Keeping float precision issues at bay
        return Number(result.toFixed(6));
    }
    /**
     * How many events of a given type can still be charged for before reaching the limit;
     * If the event is not registered, returns Infinity (free of charge)
     */
    calculateMaxEventChargeCountWithinLimit(eventName) {
        if (this.chargingState === undefined) {
            throw new Error('ChargingManager is not initialized');
        }
        const price = this.calculateEventPrice(eventName);
        if (!price) {
            return Infinity;
        }
        return this.calculateMaxChargesByPrice(price);
    }
    calculateEventPrice(eventName) {
        return this.isAtHome ? this.pricingInfo[eventName]?.price : 1; // Use a nonzero price for local development so that the maximum budget can be reached
    }
    calculateMaxChargesByPrice(price) {
        // The raw number of events allowed by the budget
        const unroundedResult = (this.maxTotalChargeUsd - this.calculateTotalChargedAmount()) /
            price;
        // First round as Math.floor(4.9999999999999999) will incorrectly return 5
        const roundedResult = Math.floor(Number(unroundedResult.toFixed(4)));
        return Math.max(0, roundedResult);
    }
    /**
     * Helper to calculate how many items can be pushed within charging limits.
     * Returns the limited items and count to charge.
     */
    calculatePushDataLimits({ items, eventName, isDefaultDataset, }) {
        if (this.chargingState === undefined) {
            throw new Error('ChargingManager is not initialized');
        }
        const itemsArray = Array.isArray(items) ? items : [items];
        const itemPrice = ((eventName !== undefined
            ? this.calculateEventPrice(eventName)
            : undefined) ?? 0) +
            ((isDefaultDataset
                ? this.calculateEventPrice(exports.DEFAULT_DATASET_ITEM_EVENT)
                : undefined) ?? 0);
        const maxChargedCount = itemPrice > 0
            ? this.calculateMaxChargesByPrice(itemPrice)
            : Infinity;
        const itemsToKeep = Math.min(itemsArray.length, maxChargedCount);
        const eventsToCharge = {};
        if (eventName !== undefined) {
            eventsToCharge[eventName] = itemsToKeep;
        }
        if (isDefaultDataset) {
            eventsToCharge[exports.DEFAULT_DATASET_ITEM_EVENT] = itemsToKeep;
        }
        return {
            limitedItems: itemsToKeep >= itemsArray.length
                ? itemsArray
                : itemsArray.slice(0, itemsToKeep),
            eventsToCharge,
        };
    }
}
exports.ChargingManager = ChargingManager;
/**
 * Helper for PPE-aware pushing of data to the dataset.
 *
 * 1. Calculate limits based on budget
 * 2. Push limited items via the provided callback
 * 3. Charge for the events
 *
 * @internal
 */
async function pushDataAndCharge({ chargingManager, items, eventName, isDefaultDataset, pushFn, }) {
    const { limitedItems, eventsToCharge } = chargingManager.calculatePushDataLimits({
        items,
        eventName,
        isDefaultDataset,
    });
    if (limitedItems.length > 0) {
        // Preserve original call shape for single items
        await pushFn(Array.isArray(items) ? limitedItems : limitedItems[0]);
    }
    if (Object.keys(eventsToCharge).length > 0) {
        const results = {};
        await Promise.all(Object.entries(eventsToCharge).map(async ([name, count]) => {
            results[name] = await chargingManager.charge({
                eventName: name,
                count,
            });
        }));
        // Merge all charge results so that eventChargeLimitReached reflects
        // whether ANY of the charged events hit their limit.
        return Object.values(results).reduce(mergeChargeResults);
    }
    return {
        eventChargeLimitReached: false,
        chargedCount: 0,
        chargeableWithinLimit: {},
    };
}
//# sourceMappingURL=charging.js.map