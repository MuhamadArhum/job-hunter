/**
 * Orchestrator Agent
 * Central controller for managing agent collaboration and intent detection
 */

const { logAgentActivity, createTrace } = require('../../services/langchain/langfuse');
const { OrchestratorChains } = require('../../services/langchain/chains');
const Agent = require('../../models/Agent');
const Task = require('../../models/Task');
const Memory = require('../../models/Memory');
const Approval = require('../../models/Approval');

// Agent configuration
const AGENTS = {
  orchestrator: {
    id: 'orchestrator',
    name: 'Orchestrator',
    description: 'Main controller and intent classifier',
  },
  jobSearch: {
    id: 'jobSearch',
    name: 'Job Search Agent',
    description: 'Finds and matches job opportunities',
  },
  resumeBuilder: {
    id: 'resumeBuilder',
    name: 'Resume Builder Agent',
    description: 'Builds and optimizes resumes',
  },
  apply: {
    id: 'apply',
    name: 'Apply Agent',
    description: 'Sends applications and tracks them',
  },
  prep: {
    id: 'prep',
    name: 'Preparation Agent',
    description: 'Interview preparation and practice',
  },
};

class OrchestratorAgent {
  constructor(userId) {
    this.userId = userId;
    this.sessionId = null;
    this.currentTasks = [];
    this.agentStatuses = {};
    this.trace = null;
  }

  /**
   * Initialize orchestrator for a user session
   */
  async initialize(sessionId) {
    this.sessionId = sessionId || `session_${Date.now()}`;
    this.trace = createTrace('orchestrator_session', this.userId);
    
    logAgentActivity('orchestrator', 'initialized', { 
      userId: this.userId, 
      sessionId: this.sessionId 
    });

    // Initialize agent statuses
    for (const [id, agent] of Object.entries(AGENTS)) {
      this.agentStatuses[id] = {
        ...agent,
        status: 'idle',
        currentTask: null,
        progress: { current: 0, total: 100, message: '' },
      };
    }

    // Ensure agents exist in database
    await this.syncAgentsToDb();
    
    return this;
  }

  /**
   * Sync agent states to database
   */
  async syncAgentsToDb() {
    for (const [id, agent] of Object.entries(AGENTS)) {
      await Agent.findOneAndUpdate(
        { userId: this.userId, agentId: id },
        {
          userId: this.userId,
          agentId: id,
          agentName: agent.name,
          status: 'idle',
        },
        { upsert: true, new: true }
      );
    }
  }

  /**
   * Process user message and determine actions
   */
  async processMessage(message, context = {}) {
    const span = this.trace?.span({ name: 'process_message' });
    
    try {
      // Save user message to conversation memory
      await this.saveToMemory('conversation', 'last_message', { 
        role: 'user', 
        content: message,
        timestamp: new Date().toISOString(),
      });

      // Detect intent
      logAgentActivity('orchestrator', 'detecting_intent', { message });
      const intentResult = await OrchestratorChains.detectIntent(message, this.userId);
      
      logAgentActivity('orchestrator', 'intent_detected', intentResult);

      // Save intent to memory
      await this.saveToMemory('conversation', 'last_intent', intentResult);

      // Get relevant context from memory
      const userPreferences = await this.getFromMemory('preferences');
      const recentJobs = await this.getFromMemory('recent_jobs');

      // Plan tasks based on intent
      const planResult = await OrchestratorChains.planTasks(
        intentResult.intent,
        message,
        { ...intentResult.entities, preferences: userPreferences, recentJobs },
        this.userId
      );

      logAgentActivity('orchestrator', 'tasks_planned', planResult);

      // Execute tasks
      const results = await this.executeTasks(planResult.tasks, context);

      // Generate response
      const response = await this.generateResponse(message, results);

      // Save assistant response to memory
      await this.saveToMemory('conversation', 'last_response', {
        role: 'assistant',
        content: response,
        timestamp: new Date().toISOString(),
      });

      span?.end({ input: message, output: response, intent: intentResult });

      return {
        success: true,
        intent: intentResult,
        tasks: planResult.tasks,
        results,
        response,
        agentStatuses: this.agentStatuses,
        requiresApproval: planResult.requiresHumanApproval || false,
        approvalPoints: planResult.approvalPoints || [],
      };
    } catch (error) {
      logAgentActivity('orchestrator', 'error', { error: error.message, message });
      span?.end({ error: error.message });
      
      return {
        success: false,
        error: error.message,
        response: `I encountered an error: ${error.message}. Please try again or rephrase your request.`,
      };
    }
  }

  /**
   * Execute planned tasks
   */
  async executeTasks(tasks, context) {
    const results = {};
    const taskMap = new Map();

    // Create task records
    for (const task of tasks) {
      const taskId = await Task.generateTaskId(task.agent);
      taskMap.set(task.id, { ...task, taskId });
      
      // Create task in database
      await Task.create({
        userId: this.userId,
        taskId,
        agentId: task.agent,
        taskType: task.action,
        title: task.action,
        description: `Task: ${task.action}`,
        input: { ...task },
        status: 'pending',
        dependsOn: task.dependsOn || [],
        context: { sessionId: this.sessionId },
      });
    }

    // Execute tasks in order respecting dependencies
    for (const task of tasks) {
      const taskData = taskMap.get(task.id);
      
      // Check dependencies
      if (task.dependsOn && task.dependsOn.length > 0) {
        const deps = task.dependsOn.map(depId => taskMap.get(depId));
        const allCompleted = deps.every(d => d?.status === 'completed');
        
        if (!allCompleted) {
          await Task.findOneAndUpdate(
            { taskId: taskData.taskId },
            { status: 'cancelled', error: { message: 'Dependencies not met' } }
          );
          continue;
        }
      }

      // Update agent status
      await this.updateAgentStatus(task.agent, 'working', task.action);

      // Execute task with appropriate agent
      try {
        const result = await this.executeTaskWithAgent(task.agent, task, results);
        results[task.id] = { success: true, data: result };
        
        // Update task status
        await Task.findOneAndUpdate(
          { taskId: taskData.taskId },
          { status: 'completed', output: result, completedAt: new Date() }
        );
        
        // Update agent status to idle
        await this.updateAgentStatus(task.agent, 'completed', task.action);
        
        logAgentActivity('orchestrator', `task_completed`, { taskId: task.id, agent: task.agent });
      } catch (error) {
        results[task.id] = { success: false, error: error.message };
        
        await Task.findOneAndUpdate(
          { taskId: taskData.taskId },
          { status: 'failed', error: { message: error.message } }
        );
        
        await this.updateAgentStatus(task.agent, 'error', error.message);
        
        logAgentActivity('orchestrator', `task_failed`, { taskId: task.id, error: error.message });
      }
    }

    return results;
  }

  /**
   * Execute a single task with the appropriate agent
   */
  async executeTaskWithAgent(agentId, task, previousResults) {
    // Import agents dynamically to avoid circular dependencies
    const agents = {
      jobSearch: require('../jobSearch'),
      resumeBuilder: require('../resumeBuilder'),
      apply: require('../apply'),
      prep: require('../prep'),
    };

    const agent = agents[agentId];
    if (!agent) {
      throw new Error(`Unknown agent: ${agentId}`);
    }

    // Execute agent task
    return await agent.execute(this.userId, task, this.sessionId);
  }

  /**
   * Generate response based on task results
   */
  async generateResponse(message, results) {
    const agentStatuses = Object.values(this.agentStatuses).map(a => ({
      name: a.name,
      status: a.status,
      currentTask: a.currentTask,
    }));

    const recentActions = Object.entries(results).map(([id, result]) => ({
      taskId: id,
      success: result.success,
    }));

    return await OrchestratorChains.generateResponse(
      agentStatuses,
      message,
      recentActions,
      this.userId
    );
  }

  /**
   * Update agent status
   */
  async updateAgentStatus(agentId, status, currentTask = null) {
    this.agentStatuses[agentId] = {
      ...this.agentStatuses[agentId],
      status,
      currentTask,
    };

    // Update in database
    await Agent.findOneAndUpdate(
      { userId: this.userId, agentId },
      {
        status,
        currentTask,
        lastActive: new Date(),
        $push: {
          activityLog: {
            timestamp: new Date(),
            action: `status_changed_to_${status}`,
            details: { currentTask },
          },
        },
      }
    );
  }

  /**
   * Get all agent statuses
   */
  async getAgentStatuses() {
    const dbAgents = await Agent.find({ userId: this.userId });
    return dbAgents.map(a => ({
      agentId: a.agentId,
      agentName: a.agentName,
      status: a.status,
      currentTask: a.currentTask,
      progress: a.progress,
      lastActive: a.lastActive,
      stats: a.stats,
    }));
  }

  /**
   * Save to memory
   */
  async saveToMemory(category, key, value) {
    await Memory.findOneAndUpdate(
      { userId: this.userId, memoryType: 'short_term', category, key },
      {
        userId: this.userId,
        memoryType: 'short_term',
        category,
        key,
        value,
        'context.sessionId': this.sessionId,
        'metadata.expiresAt': new Date(Date.now() + 24 * 60 * 60 * 1000),
      },
      { upsert: true, new: true }
    );
  }

  /**
   * Get from memory
   */
  async getFromMemory(category, key = null) {
    const query = { userId: this.userId, memoryType: 'short_term', category };
    if (key) query.key = key;
    
    const memories = await Memory.find(query).sort({ createdAt: -1 }).limit(10);
    
    if (key) {
      return memories[0]?.value || null;
    }
    
    return memories.map(m => ({ key: m.key, value: m.value }));
  }

  /**
   * Create approval request
   */
  async createApproval(type, taskId, content, title, description) {
    const traceUrl = this.trace ? `https://langfuse.cloud/traces/${this.trace.traceId}` : null;
    
    const approval = await Approval.createPending({
      userId: this.userId,
      approvalType: type,
      taskId,
      agentId: 'orchestrator',
      title,
      description,
      content: { original: content },
      metadata: {
        urgency: 'medium',
        autoExpire: true,
        expireAfter: 30, // 30 minutes
      },
      traceUrl,
    });

    // Update agent to waiting approval
    await this.updateAgentStatus('orchestrator', 'waiting_approval', `Pending approval: ${title}`);

    // Update task
    await Task.findOneAndUpdate(
      { taskId },
      { status: 'waiting_approval', approvalId: approval._id }
    );

    return approval;
  }

  /**
   * Handle approval response
   */
  async handleApproval(approvalId, action, modifiedContent = null, comment = null) {
    const approval = await Approval.findOne({ approvalId, userId: this.userId });
    
    if (!approval) {
      throw new Error('Approval not found');
    }

    const update = {
      status: action === 'modified' ? 'modified' : action,
      respondedAt: new Date(),
      userComment: comment,
    };

    if (action === 'modified') {
      update.modifiedContent = modifiedContent;
      update.status = 'modified';
    }

    await Approval.findByIdAndUpdate(approval._id, update);

    // Resume task execution
    await Task.findOneAndUpdate(
      { taskId: approval.taskId },
      { status: 'in_progress' }
    );

    await this.updateAgentStatus('orchestrator', 'working', 'Processing approval');

    return approval;
  }

  /**
   * Get pending approvals
   */
  async getPendingApprovals() {
    return Approval.getPending(this.userId);
  }

  /**
   * End session and cleanup
   */
  async endSession() {
    if (this.trace) {
      this.trace.end();
    }
    
    logAgentActivity('orchestrator', 'session_ended', { 
      userId: this.userId, 
      sessionId: this.sessionId 
    });
  }
}

module.exports = OrchestratorAgent;
module.exports.AGENTS = AGENTS;
